package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"
	"time"

	"github.com/dh-kam/go-cert-provider/auth"
	"github.com/dh-kam/go-cert-provider/config"
	"github.com/dh-kam/go-cert-provider/graph/generated"
	"github.com/dh-kam/go-cert-provider/graph/model"
	"github.com/dh-kam/go-cert-provider/session"
	"github.com/gin-gonic/gin"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error) {
	// Get JWT secret key from context
	jwtSecretKey, _ := ctx.Value("jwt_secret_key").(string)

	// Parse JWT token
	claims, err := auth.ParseJWT(input.APIKey, jwtSecretKey)
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: fmt.Sprintf("Invalid API key: %v", err),
			User:    nil,
		}, nil
	}

	// Create session
	sessionManager := session.GetGlobalManager()
	sessionID := sessionManager.CreateSession(
		claims.UserID,
		claims.Description,
		claims.ExpiresAt.Time,
		claims.AllowedDomains,
	)

	// Set cookie if we can access the gin context
	if ginCtx, ok := ctx.Value("gin").(*gin.Context); ok {
		ginCtx.SetCookie(
			"session_id", // cookie name
			sessionID,    // cookie value
			30*60,        // max age (30 minutes)
			"/",          // path
			"",           // domain (empty for current domain)
			false,        // secure (set to true in production with HTTPS)
			true,         // httpOnly
		)
	}

	return &model.LoginResponse{
		Success: true,
		Message: "Login successful",
		User: &model.User{
			ID:          claims.UserID,
			Description: claims.Description,
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Get session ID from cookie if available
	if ginCtx, ok := ctx.Value("gin").(*gin.Context); ok {
		sessionID, err := ginCtx.Cookie("session_id")
		if err == nil && sessionID != "" {
			// Delete session
			sessionManager := session.GetGlobalManager()
			sessionManager.DeleteSession(sessionID)

			// Clear cookie
			ginCtx.SetCookie(
				"session_id",
				"",
				-1, // max age -1 to delete cookie
				"/",
				"",
				false,
				true,
			)
		}
	}

	return true, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.Health, error) {
	return &model.Health{
		Status:    "ok",
		Timestamp: time.Now().Format("2006-01-02 15:04:05"),
	}, nil
}

// Version is the resolver for the version field.
func (r *queryResolver) Version(ctx context.Context) (*model.Version, error) {
	return &model.Version{
		Version:   config.Version,
		BuildTime: config.BuildTime,
		GitCommit: config.GitCommit,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get session ID from cookie if available
	if ginCtx, ok := ctx.Value("gin").(*gin.Context); ok {
		sessionID, err := ginCtx.Cookie("session_id")
		if err != nil || sessionID == "" {
			return nil, nil // No session cookie
		}

		// Get session
		sessionManager := session.GetGlobalManager()
		userSession, exists := sessionManager.GetSession(sessionID)
		if !exists {
			return nil, nil // Session not found or expired
		}

		return &model.User{
			ID:          userSession.UserID,
			Description: userSession.Description,
		}, nil
	}

	return nil, nil // No gin context available
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
